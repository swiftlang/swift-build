//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Foundation
@_spi(BuildDescriptionSignatureComponents) import SWBCore
import SWBMacro
package import SWBTaskConstruction
package import SWBUtil
import struct SWBProtocol.BuildDescriptionID

/// The type of the signature for a build description.
package typealias BuildDescriptionSignature = ByteString

/// Represents the components of a build description signature.
///
/// Any difference between two ``BuildDescriptionSignatureComponents`` instances indicates that the build description should be recomputed.
package struct BuildDescriptionSignatureComponents: Codable, Hashable, Sendable {
    enum BuildCommandCategory: Codable, Hashable, Sendable {
        case preprocess
        case assemble
        case other
    }

    struct TargetMetadata: Codable, Hashable, Sendable {
        let name: String
        let signature: String
        let buildParameters: BuildParameters
        let provisioningInputs: ProvisioningTaskInputs
        let macroConfigSignature: FilesSignature
        let specializeGuidForActiveRunDestination: Bool
    }

    struct ProjectMetadata: Codable, Hashable, Sendable {
        let name: String
        let macroConfigSignature: FilesSignature
    }

    struct SDKMetadata: Codable, Hashable, Sendable {
        let canonicalName: String
        let productBuildVersion: String?
    }

    let workspaceSignature: String
    let buildRequestParameters: BuildParameters
    let useParallelTargets: Bool
    let useImplicitDependencies: Bool
    let buildCommandCategory: BuildCommandCategory
    let enableStaleFileRemoval: Bool
    let targets: [TargetMetadata]
    let projects: [ProjectMetadata]
    let systemInfo: SystemInfo?
    let userInfo: UserInfo?
    let developerPath: Path
    let xcodeVersionString: String
    let xcodeProductBuildVersionString: String
    let buildServiceModTime: Date
    let sdkVersions: [SDKMetadata]

    /// Computes a stable content-based signature for a target that is deterministic
    /// across xcodebuild invocations, unlike the PIF-derived target.signature which
    /// includes volatile build file GUIDs regenerated by xcodebuild on each invocation.
    ///
    /// This resolves file reference GUIDs to their stable source tree paths and hashes
    /// all meaningful target structural data (build phases, files, dependencies, etc.)
    /// to produce a signature that only changes when the target's actual content changes.
    private static func stableTargetSignature(for target: Target, in workspace: Workspace) -> String {
        let hashContext = InsecureHashContext()

        // Stable target identity
        hashContext.add(string: target.guid)
        hashContext.add(string: target.name)

        // Build phase content (the primary source of volatile GUIDs)
        if let bpTarget = target as? BuildPhaseTarget {
            for phase in bpTarget.buildPhases {
                hashContext.add(string: String(describing: type(of: phase)))

                // For shell script phases, include the script content and I/O paths
                if let scriptPhase = phase as? ShellScriptBuildPhase {
                    hashContext.add(string: scriptPhase.scriptContents)
                    hashContext.add(string: scriptPhase.shellPath.stringRep)
                    for path in scriptPhase.inputFilePaths {
                        hashContext.add(string: path.stringRep)
                    }
                    for path in scriptPhase.inputFileListPaths {
                        hashContext.add(string: path.stringRep)
                    }
                    for path in scriptPhase.outputFilePaths {
                        hashContext.add(string: path.stringRep)
                    }
                    for path in scriptPhase.outputFileListPaths {
                        hashContext.add(string: path.stringRep)
                    }
                }

                // Resolve each build file to stable identifiers (paths instead of GUIDs)
                if let phaseWithFiles = phase as? BuildPhaseWithBuildFiles {
                    for buildFile in phaseWithFiles.buildFiles {
                        switch buildFile.buildableItem {
                        case .reference(let guid):
                            if let ref = workspace.lookupReference(for: guid) as? GroupTreeReference {
                                hashContext.add(string: ref.sourceTree.debugDescription)
                                hashContext.add(string: ref.path.stringRep)
                            } else if let ref = workspace.lookupReference(for: guid) as? ProductReference {
                                hashContext.add(string: "productRef:")
                                hashContext.add(string: ref.name)
                            }
                        case .targetProduct(let guid):
                            hashContext.add(string: "targetProduct:")
                            hashContext.add(string: guid)
                        case .namedReference(let name, let fileTypeIdentifier):
                            hashContext.add(string: "namedRef:")
                            hashContext.add(string: name)
                            hashContext.add(string: fileTypeIdentifier)
                        }

                        // Include build file metadata that affects build behavior
                        if let visibility = buildFile.headerVisibility {
                            hashContext.add(string: String(describing: visibility))
                        }
                        if let args = buildFile.additionalArgs {
                            hashContext.add(string: args.stringRep)
                        }
                        for filter in buildFile.platformFilters.sorted() {
                            hashContext.add(string: "pf:\(filter.platform):\(filter.environment)")
                        }
                        hashContext.add(string: String(describing: buildFile.resourceRule))
                    }
                }
            }
        }

        // Product type (affects how the target is built)
        if let stdTarget = target as? StandardTarget {
            hashContext.add(string: stdTarget.productTypeIdentifier)
            hashContext.add(string: stdTarget.productReference.name)
        }

        // Dependencies (using stable target GUIDs)
        for dep in target.dependencies {
            hashContext.add(string: dep.guid)
            for filter in dep.platformFilters.sorted() {
                hashContext.add(string: "pf:\(filter.platform):\(filter.environment)")
            }
        }

        // Build configuration names (settings are captured separately by macroConfigSignature)
        for config in target.buildConfigurations {
            hashContext.add(string: config.name)
        }

        return hashContext.signature.asString
    }

    /// Normalizes a PIF object signature by stripping the volatile `_subobjects=...`
    /// suffix. The subobjects hash includes volatile PIF GUIDs from child objects
    /// (projects, targets), but those are already captured separately in the
    /// `targets` and `projects` arrays of this struct.
    private static func normalizedPIFSignature(_ signature: String) -> String {
        if let range = signature.range(of: "_subobjects=") {
            return String(signature[..<range.lowerBound])
        }
        return signature
    }

    fileprivate init(_ request: BuildPlanRequest) {
        workspaceSignature = Self.normalizedPIFSignature(request.workspaceContext.workspace.signature)
        buildRequestParameters = request.buildRequest.parameters
        useParallelTargets = request.buildRequest.useParallelTargets
        useImplicitDependencies = request.buildRequest.useImplicitDependencies
        switch request.buildRequest.buildCommand {
        case .generatePreprocessedFile:
            buildCommandCategory = .preprocess
        case .generateAssemblyCode:
            buildCommandCategory = .assemble
        default:
            buildCommandCategory = .other
        }
        enableStaleFileRemoval = request.buildRequest.buildCommand.shouldEnableStaleFileRemoval
        let workspace = request.workspaceContext.workspace
        targets = request.buildGraph.allTargets.map {
            TargetMetadata(
                name: $0.target.name,
                signature: Self.stableTargetSignature(for: $0.target, in: workspace),
                buildParameters: $0.parameters,
                provisioningInputs: request.provisioningInputs(for: $0),
                macroConfigSignature: request.buildRequestContext.getCachedSettings($0.parameters, target: $0.target).macroConfigSignature,
                specializeGuidForActiveRunDestination: $0.specializeGuidForActiveRunDestination)
        }
        projects = request.workspaceContext.workspace.projects.map {
            ProjectMetadata(
                name: $0.name,
                macroConfigSignature: request.buildRequestContext.getCachedSettings(request.buildRequest.parameters, project: $0).macroConfigSignature)
        }
        systemInfo = request.workspaceContext.systemInfo
        userInfo = request.workspaceContext.userInfo
        developerPath = request.workspaceContext.core.developerPath.path
        xcodeVersionString = request.workspaceContext.core.xcodeVersionString
        xcodeProductBuildVersionString = request.workspaceContext.core.xcodeProductBuildVersionString
        buildServiceModTime = request.workspaceContext.core.buildServiceModTime

        // Add the ProductBuildVersion of installed SDKs, in case they are updated independently of Xcode
        sdkVersions = request.workspaceContext.core.sdkRegistry.allSDKs.sorted(by: \.canonicalName).map {
            SDKMetadata(canonicalName: $0.canonicalName, productBuildVersion: $0.productBuildVersion)
        }
    }
}

extension BuildDescriptionSignatureComponents {
    var humanReadableString: ByteString {
        get throws {
            try ByteString(JSONEncoder(outputFormatting: [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]).encode(self))
        }
    }

    func signatureStringValue(humanReadableString: ByteString) -> BuildDescriptionSignature {
        let hashContext = InsecureHashContext()
        hashContext.add(bytes: humanReadableString)
        return hashContext.signature
    }
}

extension BuildDescriptionSignature {
    /// Compare data that is used to compute the build description signature of two build plan requests and return a string
    /// with the list of differences or `nil` if they are equal.
    static func compareBuildDescriptionSignatures(_ request: BuildPlanRequest, _ otherRequest: BuildPlanRequest, _ cacheDir: Path) throws -> (previousSignaturePath: Path, currentSignaturePath: Path)? {
        let requestComponents = BuildDescriptionSignatureComponents(request)
        let otherRequestComponents = BuildDescriptionSignatureComponents(otherRequest)
        if requestComponents == otherRequestComponents {
            return nil
        }

        let fs = request.workspaceContext.fs
        let tempDir = try fs.createTemporaryDirectory(parent: fs.realpath(Path.temporaryDirectory))

        func write(_ components: BuildDescriptionSignatureComponents, _ name: String) throws -> Path {
            let path = tempDir.join("\(name).signature")
            try request.workspaceContext.fs.write(path, contents: components.humanReadableString)
            return path
        }

        return try (
            previousSignaturePath: write(otherRequestComponents, "previous"),
            currentSignaturePath: write(requestComponents, "current")
        )
    }

    /// Returns the signature to use to cache a build description for a particular workspace and request.
    package static func buildDescriptionSignature(_ request: BuildPlanRequest, cacheDir: Path) throws -> BuildDescriptionSignature {
        let signatureComponents = BuildDescriptionSignatureComponents(request)
        let humanReadableString = try signatureComponents.humanReadableString
        let signature = signatureComponents.signatureStringValue(humanReadableString: humanReadableString)

        if request.workspaceContext.userPreferences.enableDebugActivityLogs {
            let detailsPath = BuildDescription.buildDescriptionPackagePath(inDir: cacheDir, signature: signature).join("description.signature")
            try request.workspaceContext.fs.createDirectory(detailsPath.dirname, recursive: true)
            try request.workspaceContext.fs.write(detailsPath, contents: humanReadableString)
        }

        return signature
    }

    /// Returns the signature to use for a build description for a particular build description ID.
    static func buildDescriptionSignature(_ buildDescriptionID: BuildDescriptionID) -> BuildDescriptionSignature {
        return BuildDescriptionSignature(encodingAsUTF8: buildDescriptionID.rawValue)
    }
}
